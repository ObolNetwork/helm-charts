name: Test Charts

on:
  workflow_dispatch:
  pull_request:
    branches:
      - main
    paths:
      - "charts/**"
      - ".github/helm-ci-values/**"
      - ".github/workflows/test.yml"
  push:
    branches:
      - main
    paths:
      - "charts/**"
      - ".github/helm-ci-values/**"
      - ".github/workflows/test.yml"

permissions: {}

jobs:
  fetch-versions:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Get latest 4 Kubernetes minor versions from kind
        id: set-matrix
        run: |
          # Fetch all tags, extract unique minor versions, pick the latest 4
          ALL_TAGS=$(curl -s "https://registry.hub.docker.com/v2/repositories/kindest/node/tags?page_size=100" \
            | jq -r '.results[].name' \
            | grep --color=never -E '^v[0-9]+\.[0-9]+\.[0-9]+$')

          # Get unique minor versions (v1.35, v1.34, ...) sorted descending, take top 4
          MINORS=$(echo "$ALL_TAGS" | sed 's/\.[0-9]*$//' | sort -Vru | head -4)

          matrix=$(jq -n '[]')
          for minor in $MINORS; do
            latest=$(echo "$ALL_TAGS" | grep --color=never "^${minor}\." | sort -V | tail -1)
            if [[ -n "$latest" ]]; then
              matrix=$(echo "$matrix" | jq --arg version "$latest" '. + [{kubernetes_version: $version}]')
              echo "Found: $latest"
            fi
          done

          matrix=$(echo "$matrix" | jq -c '{include: .}')
          echo "Generated matrix: $matrix"
          echo "matrix=$matrix" >> $GITHUB_OUTPUT

  test:
    needs: fetch-versions
    runs-on: ubuntu-latest
    strategy:
      matrix: ${{fromJson(needs.fetch-versions.outputs.matrix)}}
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Set up kind
        uses: helm/kind-action@v1.13.0
        with:
          node_image: "kindest/node:${{ matrix.kubernetes_version }}"

      - name: Install Helm
        uses: azure/setup-helm@v4.3.1
        with:
          version: latest

      - name: Install jq
        run: sudo apt-get install -y jq

      - name: Install MetalLB
        run: |
          kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.13.7/config/manifests/metallb-native.yaml

      - name: Create MetalLB Secret
        run: |
          kubectl create secret generic -n metallb-system memberlist \
            --from-literal=secretkey="$(openssl rand -base64 128)"

      - name: Wait for MetalLB webhook
        run: |
          echo "Waiting for MetalLB webhook to be ready..."
          kubectl wait --namespace metallb-system \
            --for=condition=Available deployment/controller \
            --timeout=180s

      - name: Configure MetalLB IP Address Pool
        run: |
          subnet=$(docker network inspect kind | jq -r '.[].IPAM.Config[].Subnet | select(contains(":") | not)')
          address_first_octets=$(echo "${subnet}" | awk -F. '{printf "%s.%s",$1,$2}')
          address_range="${address_first_octets}.255.200-${address_first_octets}.255.250"

          echo "Configuring MetalLB with address range: ${address_range}"

          kubectl apply -f - <<EOF
          apiVersion: metallb.io/v1beta1
          kind: IPAddressPool
          metadata:
            namespace: metallb-system
            name: kube-services
          spec:
            addresses:
            - ${address_range}
          ---
          apiVersion: metallb.io/v1beta1
          kind: L2Advertisement
          metadata:
            name: kube-services
            namespace: metallb-system
          spec:
            ipAddressPools:
            - kube-services
          EOF

      - name: Install Prometheus Operator
        run: |
          helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
          helm repo update
          helm install prometheus prometheus-community/kube-prometheus-stack

      - name: Create cluster-lock Secret
        env:
          CLUSTER_LOCK: ${{ secrets.CLUSTER_LOCK }}
        run: |
          kubectl create secret generic cluster-lock \
            --from-literal=cluster-lock.json="$CLUSTER_LOCK"

      - name: Create charon-enr-private-key Secret
        env:
          CHARON_ENR_PRIVATE_KEY: ${{ secrets.CHARON_CLUSTER_0_CHARON_ENR_PRIVATE_KEY }}
        run: |
          echo "Creating secret charon-enr-private-key ..."

          kubectl create secret generic charon-enr-private-key \
            --from-literal=charon-enr-private-key="$CHARON_ENR_PRIVATE_KEY"

          echo "Secret charon-enr-private-key created"

      - name: Create charon-enr-private-key Secrets
        env:
          NODE_COUNT: 4
          CHARON_CLUSTER_0_CHARON_ENR_PRIVATE_KEY: ${{ secrets.CHARON_CLUSTER_0_CHARON_ENR_PRIVATE_KEY }}
          CHARON_CLUSTER_1_CHARON_ENR_PRIVATE_KEY: ${{ secrets.CHARON_CLUSTER_1_CHARON_ENR_PRIVATE_KEY }}
          CHARON_CLUSTER_2_CHARON_ENR_PRIVATE_KEY: ${{ secrets.CHARON_CLUSTER_2_CHARON_ENR_PRIVATE_KEY }}
          CHARON_CLUSTER_3_CHARON_ENR_PRIVATE_KEY: ${{ secrets.CHARON_CLUSTER_3_CHARON_ENR_PRIVATE_KEY }}
        run: |
          for i in $(seq 0 $((NODE_COUNT - 1))); do
            echo "Creating charon-enr-private-key for node $i..."

            ENR_SECRET_VAR="CHARON_CLUSTER_${i}_CHARON_ENR_PRIVATE_KEY"
            ENR_SECRET_VALUE="${!ENR_SECRET_VAR}"

            kubectl create secret generic charon-cluster-${i}-charon-enr-private-key \
              --from-literal=charon-enr-private-key="$ENR_SECRET_VALUE"

            echo "Secret charon-cluster-${i}-charon-enr-private-key created"
          done

      - name: Create validator-keys Secret
        env:
          VALIDATOR_KEYSTORE_0_JSON: ${{ secrets.VALIDATOR_KEYSTORE_0_JSON }}
          VALIDATOR_KEYSTORE_0_TXT: ${{ secrets.VALIDATOR_KEYSTORE_0_TXT }}
        run: |
          echo "Creating secret validator-keys ..."

          kubectl create secret generic validator-keys \
            --from-literal=keystore-0.json="$VALIDATOR_KEYSTORE_0_JSON" \
            --from-literal=keystore-0.txt="$VALIDATOR_KEYSTORE_0_TXT"

          echo "Secret validator-keys created"

      - name: Lint and validate all Helm charts
        run: |
          # Charts that can run standalone in kind (no external deps)
          install_file=".github/helm-ci-values/install-charts.txt"
          install_list=()
          if [[ -f "$install_file" ]]; then
            mapfile -t install_list < "$install_file"
          fi

          for chart_path in charts/*/; do
            chart=$(basename "$chart_path")
            values_file=".github/helm-ci-values/values-$chart.yaml"

            if [[ -f "$values_file" ]]; then
              values_flag="--values $values_file"
              echo "Using values file for $chart: $values_file"
            else
              values_flag=""
            fi

            echo ""
            echo "===== $chart ====="

            echo "Linting $chart..."
            helm lint "$chart_path" $values_flag

            echo "Rendering templates for $chart..."
            helm template "$chart" "$chart_path" $values_flag > /dev/null

            # Full install only for charts that work standalone in kind
            if printf '%s\n' "${install_list[@]}" | grep -qx "$chart"; then
              echo "Installing $chart (full install + wait)..."
              helm install "$chart" "$chart_path" $values_flag --wait
            else
              echo "Dry-run install for $chart..."
              helm install "$chart" "$chart_path" $values_flag --dry-run
            fi
          done

      - name: Dump pod logs and events on failure
        if: failure()
        run: |
          echo "=== Pod Status ==="
          kubectl get pods -A --no-headers | grep -v Running || true
          echo ""
          echo "=== Pod Logs (non-running) ==="
          for pod in $(kubectl get pods -A --no-headers | grep -v Running | awk '{print $1"/"$2}'); do
            ns=$(echo "$pod" | cut -d/ -f1)
            name=$(echo "$pod" | cut -d/ -f2)
            echo "--- $ns/$name ---"
            kubectl logs -n "$ns" "$name" --all-containers --tail=50 2>&1 || true
          done
          echo ""
          echo "=== Recent Events ==="
          kubectl get events -A --sort-by='.lastTimestamp' | tail -40 || true

      - name: Cleanup
        if: always()
        run: kind delete cluster
