# Ethereum Node Record (ENR) Management in the Charon Cluster

This document explains how the Ethereum Node Record (ENR) is managed for the Charon distributed validator cluster deployed by this Helm chart. The chart implements a **single, shared ENR** model, meaning all Charon pods in the cluster will share the same P2P identity.

## Overview

The ENR consists of a private key (secp256k1) and a corresponding public ENR string. The private key is essential for the Charon client to identify itself on the network, while the public ENR string is used by other nodes to discover and connect to it.

This chart provides three ways to manage the shared ENR private key:

1.  **Provide Private Key Directly**: You can specify the ENR private key directly in the `values.yaml` file.
2.  **Use an Existing Kubernetes Secret**: You can point the chart to an existing Kubernetes secret that already contains the ENR private key.
3.  **Automatic Generation**: If no private key or existing secret is provided, the chart will automatically generate a new ENR private key and its corresponding public ENR string during installation/upgrade using a pre-install Helm hook Job.

In all cases, the ENR private key and the public ENR string are stored in a Kubernetes secret. This secret is then mounted into each Charon pod, and the Charon client is configured to use this key.

## Configuration Options (`values.yaml`)

The relevant configuration parameters for ENR management can be found in the `values.yaml` file under the `charon.enr` and `charon.config` sections.

```yaml
charon:
  # --- Configuration for a single, shared ENR for the entire Charon cluster ---
  enr:
    # -- Provide the shared ENR private key directly (hex format, e.g., 0x...). 
    # If set, 'generate' and 'existingSecret' are ignored.
    privateKey: ""

    # -- Point to an existing Kubernetes secret that holds the shared ENR private key.
    # If 'privateKey' above is not set and this 'existingSecret.name' is provided, 'generate' is ignored.
    existingSecret:
      name: ""           # Name of the K8s secret (e.g., "my-cluster-enr-secret")
      dataKey: "private-key" # Key in the secret's 'data' field holding the private key hex string.

    # -- Enable automatic generation of a shared ENR private key.
    # This is active only if 'privateKey' and 'existingSecret.name' are NOT set.
    generate:
      enabled: true
      image:
        repository: "obolnetwork/charon"
        tag: "v1.4.2" # Or the version you intend to use
        pullPolicy: "IfNotPresent"
      # -- Image to use for kubectl operations within the ENR generation job
      kubectlImage:
        repository: "bitnami/kubectl"
        tag: "latest" # Or a specific version like "1.27"
        pullPolicy: "IfNotPresent"

  # --- Charon application internal configuration (translates to CLI flags) ---
  config:
    # -- Path within EACH Charon container where the SHARED ENR private key file will be mounted.
    privateKeyFile: "/data/charon_shared_enr_private_key"
```

### Parameter Details:

*   `charon.enr.privateKey`: Set this to your ENR private key string (hex format, e.g., `0xabcd...`). If provided, this key will be stored in a new secret.
*   `charon.enr.existingSecret.name`: If you have an existing Kubernetes secret containing the ENR private key, specify its name here.
*   `charon.enr.existingSecret.dataKey`: The key within the existing secret's `data` field that holds the private key string (defaults to `private-key`).
*   `charon.enr.generate.enabled`: Set to `true` (default) to enable automatic ENR generation if `privateKey` and `existingSecret.name` are not set.
*   `charon.enr.generate.image`: Specifies the `obolnetwork/charon` image used by the generation job to run `charon create enr`.
*   `charon.enr.generate.kubectlImage`: Specifies the image (e.g., `bitnami/kubectl`) used by the generation job to create the Kubernetes secret.
*   `charon.config.privateKeyFile`: The file path inside each Charon container where the ENR private key will be mounted. The Charon client is configured to read the key from this path.

## ENR Secret

Regardless of the method used, the ENR private key and the corresponding public ENR string are ultimately stored in a Kubernetes secret. 

*   **Secret Name**: 
    *   If `charon.enr.existingSecret.name` is used, that name is used.
    *   Otherwise (for `privateKey` input or `generate.enabled`), the secret is named `{{ template "charon.fullname" . }}-enr-key` (e.g., `myrelease-charon-cluster-enr-key` if your release is `myrelease` and chart name is `charon-cluster`). This name is generated by the `charon.enrSecretName` helper.
*   **Secret Data Keys**:
    *   `private-key`: Contains the ENR private key (hex string).
    *   `public-enr`: Contains the public ENR string (e.g., `enr:-...`).

This secret is automatically created or referenced by the chart.

## Automatic ENR Generation Job

If automatic generation is enabled (default), a pre-install/pre-upgrade Helm hook Job (`{{ .Release.Name }}-enr-job`) runs. This job performs the following steps:

1.  **Key Generation Container** (`charon-key-generator`):
    *   Uses the `obolnetwork/charon` image (`charon.enr.generate.image`).
    *   Executes `charon create enr --data-dir /enr-output`.
        *   The private key is saved to `/enr-output/charon-enr-private-key`.
        *   The public ENR string (from stdout) is saved to `/enr-output/enr_public_string`.
    *   These files are written to a shared `emptyDir` volume.

2.  **Secret Creation Container** (`kubectl-secret-creator`):
    *   Uses a `kubectl` utility image (`charon.enr.generate.kubectlImage`).
    *   Reads the private key and public ENR string from the `emptyDir` volume.
    *   Creates (or updates) the Kubernetes secret (e.g., `{{ .Release.Name }}-enr-key`) with the `private-key` and `public-enr` data using `kubectl apply`.

This two-container approach ensures that the `obolnetwork/charon` image (which doesn't contain `kubectl`) can be used for key generation, while a separate utility image handles the Kubernetes secret interaction.

## Usage by Charon Pods

The main Charon StatefulSet (`templates/statefulset.yaml`) is configured to:

1.  Mount the ENR secret (identified by the helper `{{ include "charon.enrSecretName" . }}`) as a volume.
2.  The specific private key file from the secret (data key determined by `{{ include "charon.enrSecretDataKey" . }}`) is mounted into each Charon pod at the path specified by `{{ .Values.charon.config.privateKeyFile }}`.
3.  The Charon client is started with the `--private-key-file` argument pointing to this mounted file path.

This setup ensures that all Charon pods in the cluster use the same shared ENR identity.

## Obtaining the Public ENR

After installation, if the ENR was generated or provided via `privateKey`, you can retrieve the public ENR string from the Kubernetes secret. For a release named `myrelease` in namespace `default`, you can use:

```bash
kubectl get secret {{ template "charon.fullname" . }}-enr-key -n default -o jsonpath='{.data.public-enr}' | base64 --decode
```
(Note: Replace `myrelease` with your actual Helm release name in the command above if you are not using `{{ template "charon.fullname" . }}` directly in your command line usage).

The public ENR will also be displayed in the notes section immediately after a successful Helm installation or upgrade, if generation was enabled.

If you used an `existingSecret`, query that secret instead.
