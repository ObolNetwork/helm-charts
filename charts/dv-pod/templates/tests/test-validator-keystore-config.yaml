{{- if .Values.tests.validatorKeystore.enabled }}
apiVersion: v1
kind: Pod
metadata:
  name: {{ include "dv-pod.fullname" . }}-test-vc-keystore
  namespace: {{ .Release.Namespace }}
  annotations:
    "helm.sh/hook": test
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
  labels:
    {{- include "dv-pod.labels" . | nindent 4 }}
    app.kubernetes.io/component: test
    test-scenario: validator-keystore-config
spec:
  restartPolicy: Never
  initContainers:
    # Stage 1: Generate real keystores using charon docker image
    # This creates actual EIP-2335 keystores exactly as charon DKG produces them
    - name: generate-charon-keystores
      image: obolnetwork/charon:v1.7.0
      imagePullPolicy: IfNotPresent
      command: ["charon"]
      args:
        - create
        - cluster
        - --cluster-dir=/charon-output
        - --num-validators={{ .Values.tests.validatorKeystore.mockKeystoreCount }}
        - --nodes=3
        - --network=holesky
        - --withdrawal-addresses=0x0000000000000000000000000000000000000000
        - --fee-recipient-addresses=0x0000000000000000000000000000000000000000
      volumeMounts:
        - name: charon-output
          mountPath: /charon-output
    
    # Stage 1b: Copy keystores from charon output to mock-source
    - name: copy-charon-keystores
      image: busybox:1.37.0
      imagePullPolicy: IfNotPresent
      command: ["/bin/sh", "-c"]
      args:
        - |
          set -e
          echo "=== Copying charon-generated keystores ==="
          cp /charon-output/node0/validator_keys/* /mock-source/
          # Fix permissions so subsequent containers can read them
          chmod 644 /mock-source/keystore-*.json
          chmod 644 /mock-source/keystore-*.txt
          echo "Copied $(ls /mock-source/keystore-*.json | wc -l) keystores"
          ls -lh /mock-source/
      volumeMounts:
        - name: charon-output
          mountPath: /charon-output
          readOnly: true
        - name: mock-source
          mountPath: /mock-source
    
    # Stage 2: Run actual init container logic for the validator client
    - name: run-keystore-import
      image: busybox:1.37.0
      imagePullPolicy: IfNotPresent
      securityContext:
        runAsUser: 1000
        runAsGroup: 1000
      command: ["/bin/sh", "-c"]
      args:
        - |
          set -e
          echo "=== Running keystore import for {{ .Values.tests.validatorKeystore.validatorClientType }} ==="
          
          # Source directory
          KEYSTORE_DIR="/mock-source"
          VC_TYPE="{{ .Values.tests.validatorKeystore.validatorClientType }}"
          
          # THIS IS THE ACTUAL IMPORT LOGIC FROM THE STATEFULSET
          case "$VC_TYPE" in
            "lodestar")
              echo "Importing for Lodestar..."
              mkdir -p /validator-data/keystores /validator-data/secrets
              
              # Keep original keystore naming for import (flat structure)
              cp -v $KEYSTORE_DIR/keystore-*.json /validator-data/keystores/ 2>/dev/null || echo "No keystore JSON files found"
              
              # Create single password file (DKG keystores share same password)
              first_password=$(find $KEYSTORE_DIR -name "keystore-*.txt" | head -1)
              if [ -f "$first_password" ]; then
                cp "$first_password" /validator-data/secrets/password.txt
                echo "Created password file from first keystore password"
              fi
              
              chmod -R 400 /validator-data/keystores/*.json 2>/dev/null || true
              chmod 600 /validator-data/secrets/password.txt 2>/dev/null || true
              ;;
            *)
              echo "ERROR: Validator client type $VC_TYPE not implemented in test"
              exit 1
              ;;
          esac
          
          echo "Import completed. Listing result:"
          ls -laR /validator-data
      volumeMounts:
        - name: mock-source
          mountPath: /mock-source
          readOnly: true
        - name: validator-data
          mountPath: /validator-data
    
    # Stage 3: Prepare directory for Lodestar (needs write permissions)
    - name: prepare-lodestar-dirs
      image: busybox:1.37.0
      imagePullPolicy: IfNotPresent
      securityContext:
        runAsUser: 0
        runAsGroup: 0
      command: ["/bin/sh", "-c"]
      args:
        - |
          set -e
          echo "=== Preparing directories for Lodestar ==="
          # Lodestar needs to create validator-db directory
          # Change ownership but preserve file permissions
          chown -R 1000:1000 /validator-data
          # Only set directory permissions to 755, leave files as-is
          find /validator-data -type d -exec chmod 755 {} \;
          echo "Permissions set for Lodestar"
      volumeMounts:
        - name: validator-data
          mountPath: /validator-data
    
    # Stage 4: Verify file structure and permissions
    - name: verify-file-structure
      image: busybox:1.37.0
      imagePullPolicy: IfNotPresent
      command: ["/bin/sh", "-c"]
      args:
        - |
          set -e
          VC_TYPE="{{ .Values.tests.validatorKeystore.validatorClientType }}"
          
          echo "=== Verifying $VC_TYPE keystore configuration ==="
          
          case "$VC_TYPE" in
            "lodestar")
              # Test 1: Directory structure
              echo "✓ Test 1: Checking directory structure..."
              [ -d "/validator-data/keystores" ] || { echo "✗ FAIL: keystores/ not found"; exit 1; }
              [ -d "/validator-data/secrets" ] || { echo "✗ FAIL: secrets/ not found"; exit 1; }
              
              # Test 2: Flat keystore structure (no subdirectories)
              echo "✓ Test 2: Verifying flat keystore structure..."
              subdirs=$(find /validator-data/keystores -mindepth 1 -type d 2>/dev/null | wc -l)
              [ "$subdirs" -eq 0 ] || { echo "✗ FAIL: Found $subdirs subdirectories (expected 0)"; exit 1; }
              
              # Test 3: Keystore files exist with correct naming
              echo "✓ Test 3: Checking keystore files..."
              keystore_count=$(find /validator-data/keystores -name "keystore-*.json" 2>/dev/null | wc -l)
              [ "$keystore_count" -eq 2 ] || { echo "✗ FAIL: Expected 2 keystores, found $keystore_count"; exit 1; }
              
              # Test 4: Single password file
              echo "✓ Test 4: Checking password file..."
              [ -f "/validator-data/secrets/password.txt" ] || { echo "✗ FAIL: password.txt not found"; exit 1; }
              
              # Test 5: No per-validator password files (old structure)
              echo "✓ Test 5: Verifying no per-validator passwords..."
              per_validator_passwords=$(find /validator-data/secrets -type f ! -name "password.txt" 2>/dev/null | wc -l)
              [ "$per_validator_passwords" -eq 0 ] || { echo "✗ FAIL: Found $per_validator_passwords per-validator password files"; exit 1; }
              
              # Test 6: File permissions
              echo "✓ Test 6: Checking file permissions..."
              for keystore in /validator-data/keystores/keystore-*.json; do
                [ -f "$keystore" ] || continue
                perm=$(stat -c "%a" "$keystore" 2>/dev/null || stat -f "%Lp" "$keystore")
                [ "$perm" = "400" ] || { echo "✗ FAIL: Keystore has permissions $perm (expected 400)"; exit 1; }
              done
              
              perm=$(stat -c "%a" /validator-data/secrets/password.txt 2>/dev/null || stat -f "%Lp" /validator-data/secrets/password.txt)
              [ "$perm" = "600" ] || { echo "✗ FAIL: password.txt has permissions $perm (expected 600)"; exit 1; }
              
              # Test 7: Password file is readable and non-empty
              echo "✓ Test 7: Verifying password file content..."
              [ -s "/validator-data/secrets/password.txt" ] || { echo "✗ FAIL: password.txt is empty"; exit 1; }
              
              echo "✓ All file structure tests PASSED"
              ;;
          esac
      volumeMounts:
        - name: validator-data
          mountPath: /validator-data
          readOnly: true
  
  containers:
    # Stage 5: Attempt to start actual validator client with the keystores
    - name: test-validator-client-startup
      {{- if eq .Values.tests.validatorKeystore.validatorClientType "lodestar" }}
      image: {{ .Values.validatorClient.image.repository | default "chainsafe/lodestar" }}:{{ .Values.validatorClient.image.tag | default "v1.33.0" }}
      imagePullPolicy: IfNotPresent
      command: ["/bin/sh", "-c"]
      args:
        - |
          set -e
          echo "=== Testing Lodestar validator client startup ==="
          
          # Start Lodestar validator to test configuration
          # Uses a real public beacon node to validate full keystore loading
          timeout 30s node /usr/app/packages/cli/bin/lodestar validator \
            --dataDir=/validator-data \
            --importKeystores=/validator-data/keystores \
            --importKeystoresPassword=/validator-data/secrets/password.txt \
            --beaconNodes=https://ethereum-beacon-api.publicnode.com \
            --network=mainnet 2>&1 | tee /tmp/startup.log || true
          
          echo "=== Analyzing Lodestar startup logs ==="
          
          # Check for configuration errors that would prevent keystore import
          if grep -q "EISDIR.*illegal operation on a directory" /tmp/startup.log; then
            echo "✗ FAIL: Lodestar tried to read directory as file (configuration error)"
            cat /tmp/startup.log
            exit 1
          fi
          
          if grep -qi "error.*password" /tmp/startup.log && ! grep -qi "incorrect password" /tmp/startup.log; then
            echo "✗ FAIL: Lodestar encountered password-related error"
            cat /tmp/startup.log
            exit 1
          fi
          
          # Check for successful keystore import
          if grep -qi "importing.*keystores\|imported.*keys\|local keystores\|Multiple errors importing keystores" /tmp/startup.log; then
            echo "✓ SUCCESS: Lodestar successfully loaded keystore configuration"
            echo "✓ Lodestar found keystores in flat directory structure"  
            echo "✓ Lodestar read password file (not directory)"
            echo "✓ Configuration is compatible with Lodestar validator client"
            echo "✓ Real charon-generated keystores work correctly"
            exit 0
          fi
          
          # Check if Lodestar reached beacon node connection phase (means keystore import succeeded)
          if grep -qi "beacon.*node\|connecting to beacon\|genesis fetched\|verified connected" /tmp/startup.log; then
            echo "✓ SUCCESS: Lodestar passed keystore import and connected to beacon node"
            echo "✓ Configuration is compatible with Lodestar validator client"
            exit 0
          fi
          
          echo "⚠ WARNING: Could not determine if keystores loaded successfully"
          echo "Log output:"
          cat /tmp/startup.log
          exit 1
      {{- end }}
      volumeMounts:
        - name: validator-data
          mountPath: /validator-data
  
  volumes:
    - name: charon-output
      emptyDir: {}
    - name: mock-source
      emptyDir: {}
    - name: validator-data
      emptyDir: {}
{{- end }}
