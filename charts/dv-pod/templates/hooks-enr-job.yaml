{{- if eq (include "dv-pod.shouldCreateEnrJob" .) "true" -}}
# This Job handles ENR (Ethereum Node Record) generation for Charon
# It supports three scenarios:
# 1. Secret already exists with both private-key and public-enr: Skip generation
# 2. Secret exists with only private-key: Generate public-enr and update the secret
# 3. Secret doesn't exist: Generate new ENR (or use provided private key) and create secret
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "dv-pod.fullname" . }}-enr-job
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "dv-pod.labels" . | nindent 4 }}
    app.kubernetes.io/component: enr-job
  annotations:
    "helm.sh/hook": pre-install,pre-upgrade
    "helm.sh/hook-weight": "-5" # After RBAC, before main statefulset
    "helm.sh/hook-delete-policy": "before-hook-creation"
{{- if .Values.charon.enr.generate.annotations }}
    {{- toYaml .Values.charon.enr.generate.annotations | nindent 4 }}
{{- end }}
spec:
  template:
    metadata:
      name: {{ include "dv-pod.fullname" . }}-enr-job-pod
      labels:
        {{- include "dv-pod.selectorLabels" . | nindent 8 }}
        app.kubernetes.io/component: enr-job-pod
    spec:
      restartPolicy: Never
      serviceAccountName: {{ include "dv-pod.fullname" . }}-enr-job # Service account with secret permissions
      securityContext:
        runAsUser: 1000
        runAsGroup: 1000
        fsGroup: 1000
      volumes:
        - name: enr-data
          emptyDir: {}
      initContainers:
        - name: check-existing-secret
          image: "{{ .Values.charon.enr.generate.kubectlImage.repository }}:{{ .Values.charon.enr.generate.kubectlImage.tag }}"
          imagePullPolicy: {{ .Values.charon.enr.generate.kubectlImage.pullPolicy }}
          command:
            - /bin/sh
            - -c
            - |
              set -e
              SECRET_NAME="{{ include "dv-pod.enrSecretName" . }}"
              NAMESPACE="{{ .Release.Namespace }}"
              
              # Check if the secret already exists
              echo "Checking if secret '$SECRET_NAME' already exists in namespace '$NAMESPACE'..."
              if kubectl get secret "${SECRET_NAME}" -n "${NAMESPACE}" >/dev/null 2>&1; then
                # Check if it has both private-key and public-enr
                HAS_PRIVATE_KEY=$(kubectl get secret "${SECRET_NAME}" -n "${NAMESPACE}" -o jsonpath='{.data.private-key}' 2>/dev/null || echo "")
                HAS_PUBLIC_ENR=$(kubectl get secret "${SECRET_NAME}" -n "${NAMESPACE}" -o jsonpath='{.data.public-enr}' 2>/dev/null || echo "")
                
                if [ -n "${HAS_PRIVATE_KEY}" ] && [ -n "${HAS_PUBLIC_ENR}" ]; then
                  echo "INFO: Secret '$SECRET_NAME' already exists with both private key and public ENR."
                  echo "INFO: The existing secret will be used by the pod."
                  touch /enr-shared/skip-generation
                elif [ -n "${HAS_PRIVATE_KEY}" ] && [ -z "${HAS_PUBLIC_ENR}" ]; then
                  echo "INFO: Secret '$SECRET_NAME' exists with private key only. Will generate public ENR."
                  # Extract private key for ENR generation
                  kubectl get secret "${SECRET_NAME}" -n "${NAMESPACE}" -o jsonpath='{.data.private-key}' | base64 -d > /enr-shared/existing-private-key
                  touch /enr-shared/generate-enr-only
                else
                  echo "ERROR: Secret '$SECRET_NAME' exists but is missing private key."
                  exit 1
                fi
              else
                echo "Secret '$SECRET_NAME' does not exist. ENR generation will proceed."
              fi
          volumeMounts:
            - name: enr-data
              mountPath: /enr-shared
      containers:
        - name: charon-key-generator
          image: {{ .Values.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}
          imagePullPolicy: {{ .Values.image.pullPolicy }}
          command:
            - /bin/sh
            - -c
            - |
              set -e
              # Check if we should skip generation
              if [ -f /enr-shared/skip-generation ]; then
                echo "INFO: Skipping ENR generation as secret already exists."
                exit 0
              fi
              
              mkdir -p /enr-output
              
              # Check if we only need to generate ENR from existing private key
              if [ -f /enr-shared/generate-enr-only ]; then
                echo "INFO: Using existing private key from secret to generate ENR."
                cp /enr-shared/existing-private-key /enr-output/charon-enr-private-key
                chmod 600 /enr-output/charon-enr-private-key
                echo "INFO: Generating public ENR from existing private key using 'charon enr --data-dir /enr-output' ..."
                PUBLIC_ENR_STRING=$(charon enr --data-dir /enr-output)
              elif [ -n "{{ .Values.charon.enr.privateKey }}" ]; then
                echo "INFO: Using provided ENR private key."
                # Remove 0x prefix and write to the default location within data-dir
                echo "{{ .Values.charon.enr.privateKey | trimPrefix "0x" }}" > /enr-output/charon-enr-private-key
                echo "INFO: Deriving public ENR from provided private key using 'charon enr --data-dir /enr-output' ..."
                # 'charon enr --data-dir' will read the key from /enr-output/charon-enr-private-key
                PUBLIC_ENR_STRING=$(charon enr --data-dir /enr-output)
              else
                echo "INFO: No private key provided, generating new ENR private key and public ENR using 'charon create enr --data-dir /enr-output' ..."
                # 'charon create enr --data-dir' will generate the private key file in /enr-output
                # and output the public ENR string to stdout.
                PUBLIC_ENR_STRING=$(charon create enr --data-dir /enr-output)
                # Ensure the generated private key is readable only by the owner
                if [ -f "/enr-output/charon-enr-private-key" ]; then
                  echo "INFO: Setting secure permissions on generated /enr-output/charon-enr-private-key"
                  chmod 600 /enr-output/charon-enr-private-key
                else
                  echo "ERROR: Expected private key /enr-output/charon-enr-private-key not found after generation."
                  exit 1 # or handle error appropriately
                fi
              fi

              echo "INFO: Public ENR String: ${PUBLIC_ENR_STRING}"
              # The PUBLIC_ENR_STRING might contain log lines from charon, extract just the ENR string.
              # A common pattern is that the ENR string itself is on the last line or is prefixed.
              # Assuming ENR is the last non-empty line of output, or adjust if charon's output is different.
              # A simple way: filter for 'enr:' prefix.
              CLEAN_PUBLIC_ENR_STRING=$(echo "${PUBLIC_ENR_STRING}" | grep '^enr:' | tail -n 1)
              if [ -z "${CLEAN_PUBLIC_ENR_STRING}" ]; then
                echo "ERROR: Could not extract clean ENR string from output: ${PUBLIC_ENR_STRING}"
                exit 1
              fi
              echo "${CLEAN_PUBLIC_ENR_STRING}" > /enr-output/enr_public_string

              # Ensure the private key file is present and not empty
              if [ ! -s "/enr-output/charon-enr-private-key" ]; then
                echo "ERROR: charon-enr-private-key not found or empty in /enr-output."
                ls -l /enr-output # For debugging
                exit 1
              fi
              echo "INFO: ENR private key and public string prepared in /enr-output."
          volumeMounts:
            - name: enr-data
              mountPath: /enr-output
            - name: enr-data
              mountPath: /enr-shared
        - name: kubectl-secret-creator
          image: "{{ .Values.charon.enr.generate.kubectlImage.repository }}:{{ .Values.charon.enr.generate.kubectlImage.tag }}"
          imagePullPolicy: {{ .Values.charon.enr.generate.kubectlImage.pullPolicy }}
          command:
            - /bin/sh
            - -c
            - |
              set -e
              SECRET_NAME="{{ include "dv-pod.enrSecretName" . }}"
              NAMESPACE="{{ .Release.Namespace }}"
              
              # Check if we should skip (double-check in case secret was created between containers)
              if [ -f /enr-shared/skip-generation ]; then
                echo "INFO: Skipping secret creation as it already exists with both keys."
                exit 0
              fi
              
              # Determine if we're updating existing secret or creating new
              UPDATE_MODE=false
              if [ -f /enr-shared/generate-enr-only ]; then
                UPDATE_MODE=true
                echo "INFO: Will update existing secret with generated public ENR."
              else
                # Check again if the secret already exists (race condition protection)
                echo "Double-checking if secret '$SECRET_NAME' already exists in namespace '$NAMESPACE'..."
                if kubectl get secret "${SECRET_NAME}" -n "${NAMESPACE}" >/dev/null 2>&1; then
                  echo "INFO: Secret '$SECRET_NAME' already exists. Skipping."
                  exit 0
                fi
                echo "Secret '$SECRET_NAME' does not exist. Creating from generated ENR..."
              fi
              echo "Waiting for ENR key files in /enr-input..."
              # Wait for the private key file and the public ENR string file
              while [ ! -f /enr-input/charon-enr-private-key ] || [ ! -f /enr-input/enr_public_string ]; do
                echo "Waiting for /enr-input/charon-enr-private-key and /enr-input/enr_public_string..."
                ls -l /enr-input # For debugging
                sleep 2
              done
              echo "ENR key files found."

              PRIVATE_KEY=$(cat /enr-input/charon-enr-private-key)
              PUBLIC_ENR=$(cat /enr-input/enr_public_string)

              # Further sanitize PUBLIC_ENR: 'charon create enr' output includes a log line like "Created ENR private key: ..." FIRST,
              # and THEN the "enr:-..." string. We only want the "enr:-..." part.
              # Grep for the line starting with 'enr:'
              PUBLIC_ENR_CLEANED=$(echo "$PUBLIC_ENR" | grep '^enr:')

              if [ -z "$PRIVATE_KEY" ] || [ -z "$PUBLIC_ENR_CLEANED" ]; then
                echo "ERROR: Private key or cleaned public ENR is empty."
                echo "Original Private Key Content: $(cat /enr-input/charon-enr-private-key)"
                echo "Original Public ENR Content from file: $(cat /enr-input/enr_public_string)"
                echo "Cleaned Public ENR: $PUBLIC_ENR_CLEANED"
                exit 1
              fi

              if [ "$UPDATE_MODE" = "true" ]; then
                echo "Updating existing secret '$SECRET_NAME' with generated public ENR..."
                # Use kubectl patch to add the public-enr field to existing secret
                # First base64 encode the public ENR
                PUBLIC_ENR_BASE64=$(echo -n "${PUBLIC_ENR_CLEANED}" | base64 | tr -d '\n')
                
                # Patch the secret to add the public-enr field
                kubectl patch secret "${SECRET_NAME}" \
                  --namespace="${NAMESPACE}" \
                  --type='json' \
                  -p='[{"op": "add", "path": "/data/public-enr", "value": "'${PUBLIC_ENR_BASE64}'"}]'
                
                echo "Secret '$SECRET_NAME' updated successfully with public ENR."
              else
                echo "Creating new secret '$SECRET_NAME' in namespace '$NAMESPACE'..."
                # Using kubectl create secret generic with --dry-run and kubectl apply for idempotency
                kubectl create secret generic "${SECRET_NAME}" \
                  --namespace="${NAMESPACE}" \
                  --from-literal=private-key="${PRIVATE_KEY}" \
                  --from-literal=public-enr="${PUBLIC_ENR_CLEANED}" \
                  --dry-run=client -o yaml | kubectl apply -f -
                
                echo "Secret '$SECRET_NAME' created successfully."
              fi
          volumeMounts:
            - name: enr-data
              mountPath: /enr-input
            - name: enr-data  
              mountPath: /enr-shared
      {{- with .Values.charon.enr.generate.nodeSelector }}
      nodeSelector:
        {{- toYaml . | nindent 8 }}
      {{- end }}
  backoffLimit: 3 # Number of retries before considering the job failed
{{- end }}
