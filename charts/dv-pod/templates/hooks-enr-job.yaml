{{- if eq (include "dv-pod.shouldCreateEnrJob" .) "true" -}}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "dv-pod.fullname" . }}-enr-job
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "dv-pod.labels" . | nindent 4 }}
    app.kubernetes.io/component: enr-job
  annotations:
    "helm.sh/hook": pre-install,pre-upgrade
    "helm.sh/hook-weight": "-5" # After RBAC, before main statefulset
    "helm.sh/hook-delete-policy": "before-hook-creation"
{{- if .Values.charon.enr.generate.annotations }}
    {{- toYaml .Values.charon.enr.generate.annotations | nindent 4 }}
{{- end }}
spec:
  template:
    metadata:
      name: {{ include "dv-pod.fullname" . }}-enr-job-pod
      labels:
        {{- include "dv-pod.selectorLabels" . | nindent 8 }}
        app.kubernetes.io/component: enr-job-pod
    spec:
      restartPolicy: Never
      serviceAccountName: {{ include "dv-pod.fullname" . }}-enr-job # Service account with secret permissions
      volumes:
        - name: enr-data
          emptyDir: {}
      initContainers:
        - name: check-existing-secret
          image: "{{ .Values.charon.enr.generate.kubectlImage.repository }}:{{ .Values.charon.enr.generate.kubectlImage.tag }}"
          imagePullPolicy: {{ .Values.charon.enr.generate.kubectlImage.pullPolicy }}
          command:
            - /bin/sh
            - -c
            - |
              set -e
              SECRET_NAME="{{ include "dv-pod.enrSecretName" . }}"
              NAMESPACE="{{ .Release.Namespace }}"
              
              # Check if the secret already exists
              echo "Checking if secret '$SECRET_NAME' already exists in namespace '$NAMESPACE'..."
              if kubectl get secret "${SECRET_NAME}" -n "${NAMESPACE}" >/dev/null 2>&1; then
                echo "INFO: Secret '$SECRET_NAME' already exists. Skipping ENR generation."
                echo "INFO: The existing secret will be used by the pod."
                # Create a marker file to signal other containers to skip
                touch /enr-shared/skip-generation
              else
                echo "Secret '$SECRET_NAME' does not exist. ENR generation will proceed."
              fi
          volumeMounts:
            - name: enr-data
              mountPath: /enr-shared
      containers:
        - name: charon-key-generator
          image: {{ .Values.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}
          imagePullPolicy: {{ .Values.image.pullPolicy }}
          command:
            - /bin/sh
            - -c
            - |
              set -e
              # Check if we should skip generation
              if [ -f /enr-shared/skip-generation ]; then
                echo "INFO: Skipping ENR generation as secret already exists."
                exit 0
              fi
              
              mkdir -p /enr-output
              if [ -n "{{ .Values.charon.enr.privateKey }}" ]; then
                echo "INFO: Using provided ENR private key."
                # Remove 0x prefix and write to the default location within data-dir
                echo "{{ .Values.charon.enr.privateKey | trimPrefix "0x" }}" > /enr-output/charon-enr-private-key
                echo "INFO: Deriving public ENR from provided private key using 'charon enr --data-dir /enr-output' ..."
                # 'charon enr --data-dir' will read the key from /enr-output/charon-enr-private-key
                PUBLIC_ENR_STRING=$(charon enr --data-dir /enr-output)
              else
                echo "INFO: No private key provided, generating new ENR private key and public ENR using 'charon create enr --data-dir /enr-output' ..."
                # 'charon create enr --data-dir' will generate the private key file in /enr-output
                # and output the public ENR string to stdout.
                PUBLIC_ENR_STRING=$(charon create enr --data-dir /enr-output)
                # Ensure the generated private key is readable by the next container
                if [ -f "/enr-output/charon-enr-private-key" ]; then
                  echo "INFO: Setting permissions on generated /enr-output/charon-enr-private-key"
                  chmod 644 /enr-output/charon-enr-private-key
                else
                  echo "ERROR: Expected private key /enr-output/charon-enr-private-key not found after generation."
                  exit 1 # or handle error appropriately
                fi
              fi

              echo "INFO: Public ENR String: ${PUBLIC_ENR_STRING}"
              # The PUBLIC_ENR_STRING might contain log lines from charon, extract just the ENR string.
              # A common pattern is that the ENR string itself is on the last line or is prefixed.
              # Assuming ENR is the last non-empty line of output, or adjust if charon's output is different.
              # A simple way: filter for 'enr:' prefix.
              CLEAN_PUBLIC_ENR_STRING=$(echo "${PUBLIC_ENR_STRING}" | grep '^enr:' | tail -n 1)
              if [ -z "${CLEAN_PUBLIC_ENR_STRING}" ]; then
                echo "ERROR: Could not extract clean ENR string from output: ${PUBLIC_ENR_STRING}"
                exit 1
              fi
              echo "${CLEAN_PUBLIC_ENR_STRING}" > /enr-output/enr_public_string

              # Ensure the private key file is present and not empty
              if [ ! -s "/enr-output/charon-enr-private-key" ]; then
                echo "ERROR: charon-enr-private-key not found or empty in /enr-output."
                ls -l /enr-output # For debugging
                exit 1
              fi
              echo "INFO: ENR private key and public string prepared in /enr-output."
          volumeMounts:
            - name: enr-data
              mountPath: /enr-output
            - name: enr-data
              mountPath: /enr-shared
        - name: kubectl-secret-creator
          image: "{{ .Values.charon.enr.generate.kubectlImage.repository }}:{{ .Values.charon.enr.generate.kubectlImage.tag }}"
          imagePullPolicy: {{ .Values.charon.enr.generate.kubectlImage.pullPolicy }}
          command:
            - /bin/sh
            - -c
            - |
              set -e
              SECRET_NAME="{{ include "dv-pod.enrSecretName" . }}"
              NAMESPACE="{{ .Release.Namespace }}"
              
              # Check if we should skip (double-check in case secret was created between containers)
              if [ -f /enr-shared/skip-generation ]; then
                echo "INFO: Skipping secret creation as it already exists."
                exit 0
              fi
              
              # Check again if the secret already exists (race condition protection)
              echo "Double-checking if secret '$SECRET_NAME' already exists in namespace '$NAMESPACE'..."
              if kubectl get secret "${SECRET_NAME}" -n "${NAMESPACE}" >/dev/null 2>&1; then
                echo "INFO: Secret '$SECRET_NAME' already exists. Skipping."
                exit 0
              fi
              
              echo "Secret '$SECRET_NAME' does not exist. Creating from generated ENR..."
              echo "Waiting for ENR key files in /enr-input..."
              # Wait for the private key file and the public ENR string file
              while [ ! -f /enr-input/charon-enr-private-key ] || [ ! -f /enr-input/enr_public_string ]; do
                echo "Waiting for /enr-input/charon-enr-private-key and /enr-input/enr_public_string..."
                ls -l /enr-input # For debugging
                sleep 2
              done
              echo "ENR key files found."

              PRIVATE_KEY=$(cat /enr-input/charon-enr-private-key)
              PUBLIC_ENR=$(cat /enr-input/enr_public_string)

              # Further sanitize PUBLIC_ENR: 'charon create enr' output includes a log line like "Created ENR private key: ..." FIRST,
              # and THEN the "enr:-..." string. We only want the "enr:-..." part.
              # Grep for the line starting with 'enr:'
              PUBLIC_ENR_CLEANED=$(echo "$PUBLIC_ENR" | grep '^enr:')

              if [ -z "$PRIVATE_KEY" ] || [ -z "$PUBLIC_ENR_CLEANED" ]; then
                echo "ERROR: Private key or cleaned public ENR is empty."
                echo "Original Private Key Content: $(cat /enr-input/charon-enr-private-key)"
                echo "Original Public ENR Content from file: $(cat /enr-input/enr_public_string)"
                echo "Cleaned Public ENR: $PUBLIC_ENR_CLEANED"
                exit 1
              fi

              echo "Creating/updating secret '$SECRET_NAME' in namespace '$NAMESPACE'..."
              
              # Using kubectl create secret generic with --dry-run and kubectl apply for idempotency
              kubectl create secret generic "${SECRET_NAME}" \
                --namespace="${NAMESPACE}" \
                --from-literal=private-key="${PRIVATE_KEY}" \
                --from-literal=public-enr="${PUBLIC_ENR_CLEANED}" \
                --dry-run=client -o yaml | kubectl apply -f -

              echo "Secret '$SECRET_NAME' created/updated successfully."
          volumeMounts:
            - name: enr-data
              mountPath: /enr-input
            - name: enr-data  
              mountPath: /enr-shared
      {{- with .Values.charon.enr.generate.nodeSelector }}
      nodeSelector:
        {{- toYaml . | nindent 8 }}
      {{- end }}
  backoffLimit: 3 # Number of retries before considering the job failed
{{- end }}
